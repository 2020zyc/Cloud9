<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><title>Cloud9: A MapReduce Library for Hadoop</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="../style.css" type="text/css" />
</head>

<body>

<center><table width="80%"><tbody><tr><td align="left">

<h2>Cloud<sup><small>9</small></sup>: Efficient feature vectors and maps</h2>

<p>by Jimmy Lin</p>

<p>
<small>(Page first created: 03 Jan 2009; last updated:
<script language="JavaScript" type="text/javascript">
<!--
var LastUpdated = "$Date$";
LastUpdated = LastUpdated.substring(LastUpdated.length-14, LastUpdated.length-3);
document.writeln (LastUpdated);
-->
</script>)
</small>
</p>

<div class="main">

<p>Feature vectors are ubiquitous in text processing and many other
applications.  They represent a special case
of <a href="http://en.wikipedia.org/wiki/Associative_array">associative
arrays</a> where the value is a numeric weight (say, int or float).
It would be nice to have efficient implementations of these data
structures.</p>

<p>A first stab at implementing a feature vector might be as
HashMap&lt;String,Integer&gt;.  This would, for example, be useful in
storing term frequencies in a document.  The biggest issue with this
implementation is that the value is Integer, rather than int, since
only objects can be stuffed inside Java collections.  Autoboxing
is <a href="http://www.ddj.com/java/188700760?pgno=3">slow</a>, and
storing Integer objects increases the memory
footprint.</p>

<p>To get around this, Cloud<sup><small>9</small></sup> implements
specialized versions of the standard Java HashMap class where the keys
or values or both are hard-coded as Java primitives:</p>

<table cellpadding="5" border="1">

<tr><td>Cloud<sup><small>9</small></sup> class</td>
    <td>Replaces</td>
    <td>Implemented interface</td></tr>

<tr><td>HMapKI&lt;K&gt;</td><td>HashMap&lt;K,Integer&gt;</td><td>MapKI&lt;K&gt;</td></tr>

<tr><td>HMapKF&lt;K&gt;</td><td>HashMap&lt;K,Float&gt;</td><td>MapKF&lt;K&gt;</td></tr>

<tr><td>HMapKL&lt;K&gt;</td><td>HashMap&lt;K,Long&gt;</td><td>MapKL&lt;K&gt;</td></tr>

<tr><td>HMapII</td><td>HashMap&lt;Integer,Integer&gt;</td><td>MapII</td></tr>

<tr><td>HMapIF</td><td>HashMap&lt;Integer,Float&gt;</td><td>MapIF</td></tr>

<tr><td>HMapIV</td><td>HashMap&lt;Integer,V&gt;</td><td>MapIV</td></tr>

</table>

<p>How much more efficient are these implementation?  As a benchmark,
I experimented with feature vectors where both the features and values
are ints.  The benchmark first inserts 5m random ints, and then access
all 5m ints.  The following shows running times and the memory
footprint:</p>

<table cellpadding="5" border="1">

<tr><td/>
    <td>Insertion</td>
    <td>Access</td>
    <td>Memory (per entry)</td></tr>

<tr><td>HashMap&lt;Integer,Integer&gt;</td>
    <td>3796 ms</td>
    <td>350 ms</td>
    <td>68 bytes</td>
</tr>

<tr><td>HMapKI&lt;Integer&gt;</td>
    <td>2953 ms (-22%)</td>
    <td>281 ms (-20%)</td>
    <td>52 bytes (-24%)</td>
</tr>

<tr><td>HMapII</td>
    <td>1703 ms (-55%)</td>
    <td>&nbsp;78 ms (-78%)</td>
    <td>31 bytes (-55%)</td>
</tr>

</table>

<p>Figures represent averages over 5 trials, on a 2.6 GHz Core Duo 2,
2 GB RAM, running Windows XP, Java 1.6u10 (conducted on 1/21/2009).  As
can be seen, these optimizations represent a significant improvement
in both speed and memory footprint.</p>

<p>Insertion is still relatively expensive because the default
implementation of HashMap backs every key-value pair with an Entry
object.  This goes naturally with the use of chaining for hash
collisions and supports iteration by keys, values, and entries.  The
downside, however, is object creation overhead and lots of time wasted
garbage collecting.  One solution around this is to implement some
type of object pooling, but a better solution is to write a completely
different implementation that uses open addressing to deal with hash
collisions, thereby obviating the need for actual Entry objects.</p>

<p>For use in Hadoop, there are classes that implement Writable:</p>

<table cellpadding="5" border="1">

<tr><td>Cloud<sup><small>9</small></sup> Writable</td>
    <td>Implemented interface</td></tr>

<tr><td>HMapIFW</td><td>HMapIF</td></tr>

<tr><td>HMapIIW</td><td>HMapII</td></tr>

<tr><td>HMapIVW&lt;V&gt;</td><td>HMapIV&lt;V&gt;</td></tr>

<tr><td>HMapKFW&lt;V&gt;</td><td>HMapKF&lt;K&gt;</td></tr>

<tr><td>HMapKIW&lt;V&gt;</td><td>HMapKI&lt;K&gt;</td></tr>

<tr><td>HMapSFW</td><td>HMapKF&lt;String&gt;</td></tr>

<tr><td>HMapSIW</td><td>HMapKI&lt;String&gt;</td></tr>

</table>

<p>The upside of all these classes is efficiency.  The downside is the
proliferation of a whole bunch of specialized classes... in my
opinion, this is a worthwhile tradeoff.  Use of a consistent naming
scheme helps.</p>

<p style="padding-top: 25px"><a href="../index.html">Back to main
page</a></p>

</div>

<table width="100%" border="0" cellpadding="0" cellspacing="0" style="padding-top: 10px;">
<tr><td valign="top" align="left">
</td>
<td valign="top" align="right">
  <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/us/">
  <img src="../images/creative-commons.png" border="0" alt="Creative Commons: Attribution-Noncommercial-Share Alike 3.0 United States"/>
  </a>
  <a href="http://validator.w3.org/check/referer">
  <img src="../images/valid-xhtml10.gif" border="0"
       alt="Valid XHTML 1.0!" height="31" width="88" />
  </a>
  <a href="http://jigsaw.w3.org/css-validator/check/referer">
  <img style="border:0;width:88px;height:31px"
       src="../images/vcss.gif" 
       alt="Valid CSS!" />
  </a>
</td></tr></table>

</td></tr></tbody></table></center>

</body></html>
